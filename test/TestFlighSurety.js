const truffleAssert = require('truffle-assertions');
let FlightSuretyData = artifacts.require('../FlightSuretyData');
let FlightSuretyApp = artifacts.require('../FlightSuretyApp');

let accounts;

// (0) 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 (100 ETH)
// (1) 0xf17f52151EbEF6C7334FAD080c5704D77216b732 (100 ETH)
// (2) 0xC5fdf4076b8F3A5357c5E395ab970B5B54098Fef (100 ETH)
// (3) 0x821aEa9a577a9b44299B9c15c88cf3087F3b5544 (100 ETH)
// (4) 0x0d1d4e623D10F9FBA5Db95830F7d3839406C6AF2 (100 ETH)
// (5) 0x2932b7A2355D6fecc4b5c0B6BD44cC31df247a2e (100 ETH)
// (6) 0x2191eF87E392377ec08E7c08Eb105Ef5448eCED5 (100 ETH)
// (7) 0x0F4F2Ac550A1b4e2280d04c21cEa7EBD822934b5 (100 ETH)
// (8) 0x6330A553Fc93768F612722BB8c2eC78aC90B3bbc (100 ETH)
// (9) 0x5AEDA56215b167893e80B4fE645BA6d5Bab767DE (100 ETH)

contract('FlightSuretyData', function(accs) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    accounts = accs;
});

contract('FlightSuretyApp', function(accs) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    accounts = accs;
});

describe('Testing FlightSuretyData contract', function() {

    before('setup contract', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();
        await instanceData.authorizeCaller(instanceApp.address);
    });


    it(`has correct initial isOperational() value`, async function () {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();
        // Get operating status

        let status = await instanceData.isOperational.call();
        assert.equal(status, true, "Incorrect initial operating status value");

    });

    it(`can block access to setOperatingStatus() for non-Contract Owner account`, async function () {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // Ensure that access is denied for non-Contract Owner account
        let accessDenied = false;
        try {
            await instanceData.setOperatingStatus(false, {from: config.testAddresses[2]});
        } catch (e) {
            accessDenied = true;
        }
        assert.equal(accessDenied, true, "Access not restricted to Contract Owner");

    });

    it(`can allow access to setOperatingStatus() for Contract Owner account`, async function () {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // Ensure that access is allowed for Contract Owner account
        let accessDenied = false;
        try {
            await instanceData.setOperatingStatus(false);
        } catch (e) {
            accessDenied = true;
        }
        assert.equal(accessDenied, false, "Access not restricted to Contract Owner");

    });

    it(`can block access to functions using requireIsOperational when operating status is false`, async function () {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        await instanceData.setOperatingStatus(false);

        let reverted = false;
        try {
            await config.flightSurety.setTestingMode(true);
        } catch (e) {
            reverted = true;
        }
        assert.equal(reverted, true, "Access not blocked for requireIsOperational");

        // Set it back for other tests to work
        await instanceData.setOperatingStatus(true);

    });

});
describe('Testing of FlightSuretyApp contract', function() {
    it('airline can register 4 airlines with simplified procedure ', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];

        // ACT
        try {
            await instanceApp.registerAirline(secondAirline, {from: firstAirline});
            await instanceApp.registerAirline(thirdAirline, {from: secondAirline});
            await instanceApp.registerAirline(fourthAirline, {from: thirdAirline});
        } catch (e) {
            console.log("Error registering airline.");
        }
        let result2 = await instanceApp.isAirline.call(secondAirline);
        let result3 = await instanceApp.isAirline.call(thirdAirline);
        let result4 = await instanceApp.isAirline.call(fourthAirline);


        // ASSERT
        assert.equal(result2, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result3, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result4, true, "Airline should not be able to register another airline if it hasn't provided funding");

    });


    it('airline can\'t register 5 airlines with simplified procedure ', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];
        let fifthAirline = accounts[5];

        // ACT
        try {
            await instanceApp.registerAirline(fifthAirline, {from: fourthAirline});
        } catch (e) {
            console.log("Error registering airline.");
        }
        let result2 = await instanceApp.isAirline.call(secondAirline);
        let result3 = await instanceApp.isAirline.call(thirdAirline);
        let result4 = await instanceApp.isAirline.call(fourthAirline);
        let result5 = await instanceApp.isAirline.call(fifthAirline);


        // ASSERT
        assert.equal(result2, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result3, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result4, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result5, false, "Airline should not be able to register another airline if it hasn't provided funding");

    });
    it('airline cannot register an Airline using registerAirline() if it is not funded', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let newAirline = accounts[7];

        // ACT
        try {
            await instanceApp.registerAirline(newAirline, {from: firstAirline});
        } catch (e) {

        }
        let result = await instanceApp.isAirline.call(newAirline);

        // ASSERT
        assert.equal(result, false, "Airline should not be able to register another airline if it hasn't provided funding");

    });

    it('airline can register 5 airlines with full procedure ', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];
        let fifthAirline = accounts[5];
        let price = web3.utils.toWei("3", "ether");

        // ACT
        try {
            await instanceApp.registerAirline(fifthAirline, {from: fourthAirline});
            await instanceApp.voteForAirline(fifthAirline, {from: firstAirline});
            await instanceApp.voteForAirline(fifthAirline, {from: secondAirline});
            await instanceApp.voteForAirline(fifthAirline, {from: thirdAirline});
            // await instanceApp.voteForAirline(fifthAirline, {from: fourthAirline});
            await instanceApp.fund({from: fifthAirline, value: price});
        } catch (e) {
            console.log("Error registering airline.", e);
        }
        let result2 = await instanceApp.isAirline.call(secondAirline);
        let result3 = await instanceApp.isAirline.call(thirdAirline);
        let result4 = await instanceApp.isAirline.call(fourthAirline);
        let result5 = await instanceApp.isAirline.call(fifthAirline);


        // ASSERT
        assert.equal(result2, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result3, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result4, true, "Airline should not be able to register another airline if it hasn't provided funding");
        assert.equal(result5, true, "Airline should not be able to register another airline if it hasn't provided funding");

    });

    it('client can buy insurance and receive payout ', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];
        let fifthAirline = accounts[5];
        let price = web3.utils.toWei("1", "ether");
        let thirdAirlineBalanceBefore;
        let thirdAirlineBalanceAfter;
        let passed = true;

        // ACT
        try {
            let isInsuranceBought = await instanceApp.registerFlight(firstAirline, "FV105", 16200, {
                from: secondAirline,
                value: price
            });
        } catch (e) {
            passed = false;
            console.log("Error buying insurance.", e);
        }
        // ASSERT
        assert.equal(passed, true, "Client can't buy an insurance");
    });

    it('can register oracles', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();
        const TEST_ORACLES_COUNT = 20;
        const STATUS_CODE_UNKNOWN = 0;
        const STATUS_CODE_ON_TIME = 10;
        const STATUS_CODE_LATE_AIRLINE = 20;
        const STATUS_CODE_LATE_WEATHER = 30;
        const STATUS_CODE_LATE_TECHNICAL = 40;
        const STATUS_CODE_LATE_OTHER = 50;
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];
        let fifthAirline = accounts[5];


        // ARRANGE
        let fee = await instanceApp.REGISTRATION_FEE.call();

        // ACT
        for (let a = 1; a < TEST_ORACLES_COUNT; a++) {
            await instanceApp.registerOracle({from: accounts[a], value: fee});
            let result = await instanceApp.getMyIndexes.call({from: accounts[a]});
            console.log(`Oracle Registered: ${result[0]}, ${result[1]}, ${result[2]}`);
        }
    });

    it('can request flight status from oracle', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let flight = 'ND1309'; // Course number
        let timestamp = Math.floor(Date.now() / 1000);
        const TEST_ORACLES_COUNT = 20;
        const STATUS_CODE_UNKNOWN = 0;
        const STATUS_CODE_ON_TIME = 10;
        const STATUS_CODE_LATE_AIRLINE = 20;
        const STATUS_CODE_LATE_WEATHER = 30;
        const STATUS_CODE_LATE_TECHNICAL = 40;
        const STATUS_CODE_LATE_OTHER = 50;
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];
        let fifthAirline = accounts[5];
        let index;


        // Submit a request for oracles to get status information for a flight
        let status = await instanceApp.fetchFlightStatus(firstAirline, flight, timestamp);
        truffleAssert.eventEmitted(status, 'ResponseInfoCreated', (ev) => {
            console.log("ResponseInfoCreated event ", ev);
            eventEmitted = true;
            return true;
        });
        truffleAssert.eventEmitted(status, 'OracleRequest', (ev) => {
            index = Number(ev["index"]);
            console.log("OracleRequest event, index ", index);
            return true;
        });


        // ACT

        // Since the Index assigned to each test account is opaque by design
        // loop through all the accounts and for each account, all its Indexes (indices?)
        // and submit a response. The contract will reject a submission if it was
        // not requested so while sub-optimal, it's a good test of that feature
        for (let a = 1; a < TEST_ORACLES_COUNT; a++) {

            // Get oracle information
            let oracleIndexes = await instanceApp.getMyIndexes.call({from: accounts[a]});
            for (let idx = 0; idx < 3; idx++) {

                try {
                    // Submit a response...it will only be accepted if there is an Index match
                    let isInsurancePaymentReady = await instanceApp.submitOracleResponse(oracleIndexes[idx], firstAirline, flight, timestamp, STATUS_CODE_ON_TIME, {from: accounts[a]});
                    truffleAssert.eventEmitted(isInsurancePaymentReady, 'FlightStatusInfo', (ev) => {
                        console.log("FlightStatusInfo event.");
                        eventEmitted = true;
                        return true;
                    });
                    truffleAssert.eventEmitted(isInsurancePaymentReady, 'InsurancePaymentReady', (ev) => {
                        console.log("InsurancePaymentReady event");
                        eventEmitted = true;
                        return true;
                    });
                } catch (e) {
                    // Enable this when debugging
                    // console.log('\nError', e, idx, oracleIndexes[idx].toNumber(), flight, timestamp);
                }

            }
        }


    });
    it('can submit oracle response and move flight insurance transaction into processing stage', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let flight = 'ND1309'; // Course number
        let timestamp = Math.floor(Date.now() / 1000);
        const TEST_ORACLES_COUNT = 20;
        const STATUS_CODE_UNKNOWN = 0;
        const STATUS_CODE_ON_TIME = 10;
        const STATUS_CODE_LATE_AIRLINE = 20;
        const STATUS_CODE_LATE_WEATHER = 30;
        const STATUS_CODE_LATE_TECHNICAL = 40;
        const STATUS_CODE_LATE_OTHER = 50;
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];
        let fifthAirline = accounts[5];
        let eventEmitted = false;
        let index;


        // Submit a request for oracles to get status information for a flight
        let status = await instanceApp.fetchFlightStatus(firstAirline, flight, timestamp);
        truffleAssert.eventEmitted(status, 'ResponseInfoCreated', (ev) => {
            console.log("ResponseInfoCreated event ", ev);
            eventEmitted = true;
            return true;
        });
        truffleAssert.eventEmitted(status, 'OracleRequest', (ev) => {
            index = Number(ev["index"]);
            console.log("OracleRequest event, index ", index);
            return true;
        });


        // ACT

        // Since the Index assigned to each test account is opaque by design
        // loop through all the accounts and for each account, all its Indexes (indices?)
        // and submit a response. The contract will reject a submission if it was
        // not requested so while sub-optimal, it's a good test of that feature
        for (let a = 1; a < TEST_ORACLES_COUNT; a++) {

            // Get oracle information
            let oracleIndexes = await instanceApp.getMyIndexes.call({from: accounts[a]});
            for (let idx = 0; idx < 3; idx++) {

                try {
                    // Submit a response...it will only be accepted if there is an Index match
                    let isInsurancePaymentReady = await instanceApp.submitOracleResponse(oracleIndexes[idx], firstAirline, flight, timestamp, STATUS_CODE_LATE_TECHNICAL, {from: accounts[a]});
                    truffleAssert.eventEmitted(isInsurancePaymentReady, 'FlightStatusInfo', (ev) => {
                        console.log("FlightStatusInfo event.");
                        eventEmitted = true;
                        return true;
                    });
                    truffleAssert.eventEmitted(isInsurancePaymentReady, 'InsurancePaymentReady', (ev) => {
                        console.log("InsurancePaymentReady event");
                        eventEmitted = true;
                        return true;
                    });
                } catch (e) {
                    // Enable this when debugging
                    // console.log(e);
                }

            }
        }
        assert.equal(eventEmitted, true);

    });

    it('can customer receive payout', async () => {
        const instanceData = await FlightSuretyData.deployed();
        const instanceApp = await FlightSuretyApp.deployed();

        // ARRANGE
        let flight = 'FV11'; // Course number
        let timestamp = Math.floor(Date.now() / 1000);
        const TEST_ORACLES_COUNT = 20;
        const STATUS_CODE_UNKNOWN = 0;
        const STATUS_CODE_ON_TIME = 10;
        const STATUS_CODE_LATE_AIRLINE = 20;
        const STATUS_CODE_LATE_WEATHER = 30;
        const STATUS_CODE_LATE_TECHNICAL = 40;
        const STATUS_CODE_LATE_OTHER = 50;
        let index;
        let firstAirline = accounts[0];
        let secondAirline = accounts[2];
        let thirdAirline = accounts[3];
        let fourthAirline = accounts[4];
        let fifthAirline = accounts[5];
        let sixthAirline = accounts[6];
        let price = web3.utils.toWei("1", "ether");
        // let fundPrice = web3.utils.toWei("5", "ether");
        //
        // let thirdAirlineBalanceBefore;
        // let thirdAirlineBalanceAfter;
        eventEmitted = false;
        //
        // // ACT
        // await instanceData.registerAirline(sixthAirline, {from: fifthAirline});
        // await instanceData.voteForAirline(sixthAirline, {from: firstAirline});
        // await instanceData.voteForAirline(sixthAirline, {from: secondAirline});
        // await instanceData.voteForAirline(sixthAirline, {from: thirdAirline});
        // await instanceData.voteForAirline(sixthAirline, {from: fourthAirline});
        // await instanceData.fund({from: sixthAirline, value: fundPrice});
        console.log("Balance eth ", await web3.eth.getBalance(thirdAirline));
        await instanceApp.registerFlight(firstAirline, flight, timestamp, {from: thirdAirline, value: price});
        console.log("Balance eth ", await web3.eth.getBalance(thirdAirline));
        // Submit a request for oracles to get status information for a flight
        let status = await instanceApp.fetchFlightStatus(firstAirline, flight, timestamp, {from: secondAirline});
        truffleAssert.eventEmitted(status, 'ResponseInfoCreated', (ev) => {
            console.log("ResponseInfoCreated event ", ev);
            eventEmitted = true;
            return true;
        });
        truffleAssert.eventEmitted(status, 'OracleRequest', (ev) => {
            index = Number(ev["index"]);
            console.log("Event emitted, index ", index);
            return true;
        });

        // ACT

        // Since the Index assigned to each test account is opaque by design
        // loop through all the accounts and for each account, all its Indexes (indices?)
        // and submit a response. The contract will reject a submission if it was
        // not requested so while sub-optimal, it's a good test of that feature
        for (let a = 1; a < TEST_ORACLES_COUNT; a++) {

            // Get oracle information
            let oracleIndexes = await instanceApp.getMyIndexes.call({from: accounts[a]});
            for (let idx = 0; idx < 3; idx++) {
                try {
                    // Submit a response...it will only be accepted if there is an Index match
                    let isInsurancePaymentReady = await instanceApp.submitOracleResponse(oracleIndexes[idx], firstAirline, flight, timestamp, STATUS_CODE_LATE_OTHER, {from: accounts[a]});
                    truffleAssert.eventEmitted(isInsurancePaymentReady, 'FlightStatusInfo', (ev) => {
                        console.log("FlightStatusInfo event.");
                        eventEmitted = true;
                        return true;
                    });
                    truffleAssert.eventEmitted(isInsurancePaymentReady, 'InsurancePaymentReady', (ev) => {
                        console.log("InsurancePaymentReady");
                        eventEmitted = true;
                        return true;
                    });
                } catch (e) {
                    // Enable this when debugging
                    console.log(e["reason"]);
                }
            }
        }
        console.log("Balance eth ", await web3.eth.getBalance(thirdAirline));
        let isPayed = await instanceApp.pay(firstAirline, flight, timestamp, thirdAirline, {from: thirdAirline});
        console.log("Balance eth ", await web3.eth.getBalance(thirdAirline));
        assert.equal(eventEmitted, true);

    });
});
